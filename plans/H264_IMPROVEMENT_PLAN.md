# H.264 解码器改进计划

> 本文档分析当前 H.264 解码器实现的状态, 并规划三个主要改进方向.

## 1. 当前实现状态

### 已实现的功能 ✅

- **配置解析**: AVCC 配置解析、SPS/PPS 解析和缓存
- **切片处理**: Slice header 解析、宏块循环框架
- **熵编码**: CABAC 解码器初始化、各种语法元素解码
- **宏块类型**: I_4x4、I_16x16、I_PCM 识别
- **帧内预测**:
    - 16x16 预测 (4 种模式: V/H/DC/Plane)
    - Chroma DC 预测
    - 4x4 DC 预测（简化）
- **残差处理框架**:
    - 亮度 DC 反 Hadamard 变换
    - 色度 DC 反 Hadamard 变换
    - 亮度/色度 AC 残差解码框架(消耗 CABAC 比特)
- **输出**: YUV420p 帧构建

### 当前局限性 ⚠️

1. **I_4x4 宏块**:
    - ❌ **未实现预测模式选择** - 每 4x4 块有 9 种预测模式，当前只用 DC
    - ❌ **预测映射不完整** - 缺少 Vertical/Horizontal/Diagonal/DDR 等 8 种模式
    - ✅ 消耗所有 CABAC 比特（语法正确）

2. **AC 残差应用**:
    - ✅ 解码残差系数
    - ❌ **未实际加到预测值上** - AC 残差被完全忽略
    - ⚠️ 导致细节丢失，只有粗糙预测可见

3. **帧间预测** (P/B 帧):
    - ❌ **未实现运动矢量预测 (MVP)** - 参考帧选择空
    - ❌ **副宏块模式** - P_Skip 只是复制参考帧
    - ❌ **运动补偿** - 无位移预测、双向预测
    - ⚠️ 无法处理视频中的运动内容

4. **其他功能**:
    - ✅ I 帧基本解码流程
    - ⚠️ CAVLC 仅有 DC 回退实现
    - ❌ 重链表、参考帧管理无实现

---

## 2. 三个主要改进方向

### 方向 A: 完善 I 帧解码（优先级: 🔴 最高）

**目标**: 确保 I 帧能正确解码（包括详细纹理）

**具体改进**:

1. **实现真正的 I_4x4 预测** (~300 行)
    - 添加 9 种预测模式函数
    - 修改 `decode_i4x4_mb()` 读取预测模式标志
    - 根据模式应用正确的预测
2. **实现 AC 残差应用** (~100 行)
    - 完成 `skip_luma_ac_residual()` → 实际解码并应用
    - 对 I_4x4 的每个 4x4 块应用 AC 残差
    - 添加 8x8 DCT 逆变换
3. **完善 I_16x16 残差处理** (~150 行)
    - 完成 AC 残差解码 → `skip_luma_ac_residual()`
    - 应用 AC 残差到亮度 AC 平面

**预期成果**:

- ✅ I 帧完整视觉质量（包括高频细节）
- ✅ 可与 FFmpeg 进行像素级别对比
- ✅ 所有 I 帧测试通过

**工作量**: ~550 行代码 | ~3-4 天

---

### 方向 B: 基础 P 帧支持（优先级: 🟠 中等）

**目标**: 支持包含运动补偿的简单 P 帧

**具体改进**:

1. **实现 MVP (Motion Vector Prediction)** (~400 行)
    - 邻近宏块运动矢量收集
    - 中位数计算
    - 参考索引处理
2. **实现副宏块运动** (~300 行)
    - P_L0_16x16, P_L0_16x8, P_L0_8x16, P_L0_8x8
    - 运动矢量差分 (MVD) 解码
    - 运动补偿内插
3. **参考帧管理** (~200 行)
    - 扩展 DPB (已解码图像缓冲)
    - 参考索引选择
    - 长期/短期参考跟踪

**预期成果**:

- ✅ P 帧基本运动补偿
- ✅ 简单视频场景解码
- ⚠️ 复杂运动可能有伪影

**工作量**: ~900 行代码 | ~5-7 天

---

### 方向 C: 完整的帧间预测（优先级: 🟡 较低）

**目标**: 全功能帧间预测，支持 B 帧

**具体改进**:

1. **B 帧支持** (~400 行)
    - MVP 扩展到双向预测
    - 直接/空间模式
    - 帧间/双向权重

2. **高级副宏块模式** (~300 行)
    - 1/4 像素精度内插
    - 多个参考帧选择
    - SKIP 模式优化

3. **性能优化** (~200 行)
    - 运动补偿 SIMD
    - 内插表缓存
    - 帧缓冲池

**预期成果**:

- ✅ 几乎所有场景可解码
- ✅ 接近 FFmpeg 的视觉质量
- ✅ 性能与硬件解码接近

**工作量**: ~900 行代码 | ~7-10 天

---

## 3. 建议的改进顺序

```
阶段 1 (第一周): 方向 A - I 帧完善
  Day 1: I_4x4 预测模式选择
  Day 2: AC 残差解码应用
  Day 3-4: 完整测试和优化

阶段 2 (第二周): 方向 B - P 帧基础
  Day 5-6: MVP 实现
  Day 7-8: 运动补偿
  Day 9-10: DPB 管理和测试

阶段 3 (第三周+): 方向 C - 完全功能
  Day 11+: B 帧、高级模式、性能优化
```

## 4. 优先级和依赖关系

```
┌─────────────────────────────────────┐
│ 所有 I 帧可用 (方向 A)              │  ← 基础必需
│ ├─ I_4x4 正确预测                   │
│ └─ AC 残差完整应用                   │
└────────────┬────────────────────────┘
             │
             ↓
┌─────────────────────────────────────┐
│ 简单 P 帧支持 (方向 B)              │  ← 第二优先
│ ├─ MVP                              │
│ └─ 基本运动补偿                      │
└────────────┬────────────────────────┘
             │
             ↓
┌─────────────────────────────────────┐
│ 完整帧间预测 (方向 C)               │  ← 可选扩展
│ ├─ B 帧支持                         │
│ └─ SIMD 优化                        │
└─────────────────────────────────────┘
```

## 5. 代码位置参考

### 需要修改的关键文件

1. **`mod.rs`** (主解码器)
    - 行 520-550: `decode_i4x4_mb()` - 添加真正的预测模式读取
    - 行 580-650: `consume_i4x4_residual()` - 实现 AC 残差应用
    - 行 700+: `decode_i_slice_mbs()` - P 帧 MVP 集成

2. **`intra.rs`** (帧内预测)
    - 行 190: 添加 `predict_4x4_vertical()` 等 9 种模式
    - 添加新的 `predict_4x4()` 分发函数

3. **新增: `inter.rs`** (帧间预测)
    - MVP 计算
    - 运动补偿内插
    - 参考帧管理

4. **`residual.rs`** (残差处理)
    - 完成 8x8 DCT 逆变换
    - AC 系数应用函数

### 测试文件更新

1. **`tests/h264_decode_pipeline.rs`**
    - 启用 `test_h264_intra_frame_decode` (当前为框架)
    - 启用 `test_h264_p_frame_skip_mode` (运动补偿框架)

---

## 6. 实现细节示例

### 方向 A: I_4x4 预测模式

```rust
// 当前代码 (行 515): 不读取预测模式
fn decode_i4x4_mb(...) {
    decode_i4x4_pred_modes(cabac, ctxs);  // ← 只消耗 CABAC 比特
    // ...
    // 应用简化 DC 预测
    for sub_y in 0..4 {
        for sub_x in 0..4 {
            intra::predict_4x4_dc(...);  // ← 总是 DC模式
        }
    }
}

// 需要改进为:
fn decode_i4x4_mb(...) {
    let pred_modes = read_4x4_pred_modes(cabac, ctxs);  // ← 返回 [u8; 16]
    // ...
    for sub_y in 0..4 {
        for sub_x in 0..4 {
            let idx = sub_y * 4 + sub_x;
            let mode = pred_modes[idx];
            intra::predict_4x4(mode, ...);  // ← 选择正确的预测
        }
    }
}
```

### 方向 A: AC 残差应用

```rust
// 当前代码 (行 550): 跳过残差
fn consume_i4x4_residual(..., luma_cbp: u8, ...) {
    for i8x8 in 0..4u8 {
        if luma_cbp & (1 << i8x8) != 0 {
            for _ in 0..4 {
                let _ = decode_residual_block(...);  // ← 解码后丢弃
            }
        }
    }
}

// 需要改进为:
fn decode_i4x4_residual(...) {
    for i8x8 in 0..4u8 {
        if luma_cbp & (1 << i8x8) != 0 {
            for sub_idx in 0..4 {
                let coeffs = decode_residual_block(...);  // ← 解码系数
                apply_4x4_residual(                       // ← 应用到帧
                    &mut self.ref_y,
                    ...,
                    &coeffs,
                    *cur_qp
                );
            }
        }
    }
}
```

---

## 7. 下一步行动

请选择优先改进方向:

1. **推荐**: 先完成方向 A (I 帧完善)
    - 工作量小 (~3-4 天)
    - 立刻有可见改进
    - 为后续工作打好基础

2. **可选**: 跳过方向 B/C，深入优化方向 A
    - SIMD 优化预测和 DCT
    - 性能基准测试
    - 与 FFmpeg 对标

---
