---
description: 测试规范和用例开发流程
globs:
    - "tests/**/*.rs"
    - "benches/**/*.rs"
---

# 测试规范

## 基本要求

- 代码修改后必须执行 `cargo check` 与 `cargo test`
- 如出现错误或警告, 必须先修复再继续后续修改
- **重要**: 新增编解码器或容器格式时必须编写测试
- 集成测试放在 `tests/` 目录下, 单元测试放在源文件内 `#[cfg(test)]` 模块中
- 测试用例命名需要准确描述测试内容与预期结果, 使用蛇形命名法
- 测试应覆盖正常流程, 边界情况和错误情况
- **所有样本使用 URL 方式访问**，不下载到本地 (详见 [samples/SAMPLE_URLS.md](../../samples/SAMPLE_URLS.md))
- **临时文件放在 `data/` 目录**，永不提交到 Git (详见 [15_data_management.mdc](15_data_management.mdc))

## 测试用例开发流程

### 1. 确定测试需求

明确需要测试的场景:

- 正常流程: 标准输入输出, 基本功能验证
- 边界情况: 空输入, 极限参数, 特殊格式
- 错误处理: 损坏数据, 不支持的参数, 资源不足

### 2. 查找和使用测试样本

**重要**: 所有样本使用 **HTTPS URL** 直接访问，无需下载到本地

1. **查找样本**: 在 `samples/SAMPLE_URLS.md` 中查找適用的样本 URL
2. **样本来源**: https://samples.ffmpeg.org/ (FFmpeg 官方测试样本库)
3. **验证样本**: 使用 `ffprobe <URL>` 验证样本信息
   ```bash
   ffprobe https://samples.ffmpeg.org/HDTV/Channel9_HD.ts
   ```
4. **如果没有合适样本**:
   - 访问 https://samples.ffmpeg.org/ 浏览完整样本库
   - 或查看 https://samples.ffmpeg.org/allsamples.txt
   - 使用 `ffprobe <URL>` 验证
   - 添加到 `samples/SAMPLE_URLS.md` 并提交
   ```bash
   git add samples/SAMPLE_URLS.md
   git commit -m "docs: 添加 XXX 编解码器测试样本 URL"
   ```

### 3. 编写测试用例

```rust
#[test]
fn test_codec_decode_basic() {
    // 1. 从 samples/SAMPLE_URLS.md 获取样本 URL
    let sample_url = "https://samples.ffmpeg.org/HDTV/Channel9_HD.ts";

    // 2. 直接使用 URL 打开解封装器, 无需下载文件
    let mut demuxer = DemuxerRegistry::open(sample_url).unwrap();

    // 3. 查找视频流
    let video_stream = demuxer.streams()
        .iter()
        .find(|s| s.media_type() == MediaType::Video)
        .unwrap();

    // 4. 创建解码器
    let mut decoder = DecoderRegistry::create_decoder(
        video_stream.codec_id(),
        video_stream.codec_params(),
    ).unwrap();

    // 5. 解码前几帧验证功能
    // 重要: 只解码 5-10 帧就可以验证功能, 避免测试耗时过长
    let mut frame_count = 0;
    while let Some(packet) = demuxer.read_packet().unwrap() {
        if packet.stream_index() == video_stream.index() {
            let frames = decoder.decode(&packet).unwrap();
            frame_count += frames.len();
            if frame_count >= 10 { break; }  // 限制帧数
        }
    }

    assert!(frame_count >= 10, "应该解码出至少 10 帧");
}
```

## 测试用例编写标准

- **文件位置**: `tests/{feature}_pipeline.rs`
- **测试命名**: `test_{component}_{scenario}` 格式
- **断言清晰**: 每个 `assert!` 包含失败消息说明预期行为
- **注释完整**: 复杂逻辑添加注释，建议使用 step-by-step 清晰说明
- **样本来源**: 使用 `samples/SAMPLE_URLS.md` 中的 **HTTPS URL**，无需下载
- **帧数限制**: 只解码前 5-10 帧验证功能，避免测试耗时过长（示例见第 3 节）
- **资源清理**: 临时文件放在 `data/` 目录（详见 [15_data_management.mdc](15_data_management.mdc)）
- **网络访问**: 所有测试假设有网络连接

## 测试覆盖范围

### 编解码器测试

- ✓ 基本解码 (正常流程)
- ✓ 编码 (如果实现了编码器)
- ✓ 空输入处理
- ✓ 损坏数据处理
- ✓ Flush 流程
- ✓ 参数解析 (SPS/PPS/VPS 等)

### 容器格式测试

- ✓ 格式探测 (Probe)
- ✓ 头部解析
- ✓ 数据包读取
- ✓ Seek 操作
- ✓ 多流处理 (音视频同时存在)
- ✓ 损坏文件处理

### 滤镜测试

- ✓ 基本滤镜操作
- ✓ 参数验证
- ✓ 链式滤镜
- ✓ 边界条件 (分辨率, 像素格式)
