---
description: 日志规范
globs:
    - "**/*.rs"
---

# 日志规范

## 基本原则

- 日志使用 `tracing` crate: `error!`, `warn!`, `info!`, `debug!`, `trace!`
- 日志后端使用 `tracing-subscriber` 和 `tracing-appender`
- 库 crate (tao-core, tao-codec 等) 只使用 `tracing` 宏, 不初始化日志后端
- 可执行文件 (tao-cli, tao-probe, tao-play) 负责初始化日志系统
- 日志内容使用中文

## 日志模块位置

- 日志初始化模块位于 `src/logging/`
- 包含两个文件:
    - `mod.rs` - 日志初始化和配置
    - `task.rs` - 日志维护任务 (日志切换、清理、压缩)

## 日志输出规则

### 控制台输出

- **始终固定为 debug 级别**
- 输出到 stdout
- 带颜色输出 (ANSI)
- 过滤规则: `debug`

### 文件输出

- **可通过命令行参数、环境变量等改变日志过滤级别**
- 文件级别通过 `LoggingConfig.level` 配置
- 无颜色输出 (纯文本)
- 支持按日期自动切换日志文件
- 支持历史日志压缩和自动清理

## 日志文件管理

### 日志目录

- 所有日志文件存放在项目根目录 `logs/` 目录下
- `logs/` 目录在 Git 中只保留 `.gitkeep` 文件
- 所有 `*.log` 文件都被 `.gitignore` 忽略, 不提交到 Git

### 日志文件命名

- 格式: `{file_prefix}.{YYYY-MM-DD}.log`
- 示例: `tao.2026-02-16.log`, `tao-probe.2026-02-16.log`

### 文件前缀规范

- **tao-cli**: 使用 `file_prefix = "tao"`
- **tao-probe**: 使用 `file_prefix = "tao-probe"`
- **tao-play**: 使用 `file_prefix = "tao-play"`

### 日志维护

- 自动按日期切换日志文件 (每日凌晨)
- 可配置历史日志保留天数 (默认 30 天)
- 可配置是否压缩历史日志 (默认开启, 生成 `.gz` 文件)
- 定期清理过期日志 (可配置清理间隔)

## 日志初始化示例

```rust
use tao::logging::{init, LoggingConfig};

fn main() -> anyhow::Result<()> {
    // 初始化日志系统
    init(LoggingConfig {
        level: std::env::var("TAO_LOG_LEVEL").unwrap_or_else(|_| "info".to_string()),
        directory: "logs".to_string(),
        file_prefix: "tao".to_string(),  // tao-cli 使用 "tao"
        retention_days: 30,
        compress_history: true,
        cleanup_interval_seconds: 3600,
    })?;

    // 开始使用日志
    tracing::info!("程序启动");

    Ok(())
}
```

## 日志级别使用

- `error!`: 致命错误, 无法继续处理
- `warn!`: 可恢复错误, 损坏但可跳过的数据
- `info!`: 打开文件, 识别格式, 开始/完成转码
- `debug!`: 流信息, 编解码器参数, 数据包细节
- `trace!`: 详细的调试信息, 性能追踪

## AI 调试规范

当需要调试代码时:

1. **优先查看日志文件而非控制台输出**
2. 日志文件位于 `logs/{file_prefix}.{date}.log`
3. 调试前可以删除对应的日志文件, 避免历史日志污染
4. 示例: 删除 `logs/tao.2026-02-16.log` 重新运行程序生成新日志
5. 通过日志文件分析程序执行流程和错误原因
6. 减少频繁读取控制台输出, 提高调试效率
