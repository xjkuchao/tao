//! MP3 多相合成滤波器组 (Polyphase Synthesis Filterbank)
//!
//! 将 32 个子带样本合成为 32 个 PCM 样本.
//! 包含:
//! 1. 频率反转 (Frequency Inversion)
//! 2. 32 点 DCT (Matrixing)
//! 3. 512 点窗口加权 (Windowing)
//! 4. 累加输出 (Accumulation)

/// 频率反转: 奇数子带的奇数样本取反
///
/// 注意: 仅对奇数子带(1,3,5,...,31)中的奇数时间样本(1,3,5,...,17)取反
pub fn frequency_inversion(input: &mut [f32; 576]) {
    for sb in (1..32).step_by(2) {
        for i in (1..18).step_by(2) {
            input[sb * 18 + i] = -input[sb * 18 + i];
        }
    }
}

/// 合成窗口 D[i], 来自 ISO/IEC 11172-3 Table B.3
/// 数据来源: symphonia-bundle-mp3 (已验证正确)
#[allow(clippy::unreadable_literal, clippy::excessive_precision)]
#[rustfmt::skip]
pub(crate) const SYNTH_WINDOW: [f32; 512] = [
    // D[0..63]
     0.000000000, -0.000015259, -0.000015259, -0.000015259,
    -0.000015259, -0.000015259, -0.000015259, -0.000030518,
    -0.000030518, -0.000030518, -0.000030518, -0.000045776,
    -0.000045776, -0.000061035, -0.000061035, -0.000076294,
    -0.000076294, -0.000091553, -0.000106812, -0.000106812,
    -0.000122070, -0.000137329, -0.000152588, -0.000167847,
    -0.000198364, -0.000213623, -0.000244141, -0.000259399,
    -0.000289917, -0.000320435, -0.000366211, -0.000396729,
    -0.000442505, -0.000473022, -0.000534058, -0.000579834,
    -0.000625610, -0.000686646, -0.000747681, -0.000808716,
    -0.000885010, -0.000961304, -0.001037598, -0.001113892,
    -0.001205444, -0.001296997, -0.001388550, -0.001480103,
    -0.001586914, -0.001693726, -0.001785278, -0.001907349,
    -0.002014160, -0.002120972, -0.002243042, -0.002349854,
    -0.002456665, -0.002578735, -0.002685547, -0.002792358,
    -0.002899170, -0.002990723, -0.003082275, -0.003173828,
    // D[64..127]
     0.003250122,  0.003326416,  0.003387451,  0.003433228,
     0.003463745,  0.003479004,  0.003479004,  0.003463745,
     0.003417969,  0.003372192,  0.003280640,  0.003173828,
     0.003051758,  0.002883911,  0.002700806,  0.002487183,
     0.002227783,  0.001937866,  0.001617432,  0.001266479,
     0.000869751,  0.000442505, -0.000030518, -0.000549316,
    -0.001098633, -0.001693726, -0.002334595, -0.003005981,
    -0.003723145, -0.004486084, -0.005294800, -0.006118774,
    -0.007003784, -0.007919312, -0.008865356, -0.009841919,
    -0.010848999, -0.011886597, -0.012939453, -0.014022827,
    -0.015121460, -0.016235352, -0.017349243, -0.018463135,
    -0.019577026, -0.020690918, -0.021789551, -0.022857666,
    -0.023910522, -0.024932861, -0.025909424, -0.026840210,
    -0.027725220, -0.028533936, -0.029281616, -0.029937744,
    -0.030532837, -0.031005859, -0.031387329, -0.031661987,
    -0.031814575, -0.031845093, -0.031738281, -0.031478882,
    // D[128..191]
     0.031082153,  0.030517578,  0.029785156,  0.028884888,
     0.027801514,  0.026535034,  0.025085449,  0.023422241,
     0.021575928,  0.019531250,  0.017257690,  0.014801025,
     0.012115479,  0.009231567,  0.006134033,  0.002822876,
    -0.000686646, -0.004394531, -0.008316040, -0.012420654,
    -0.016708374, -0.021179199, -0.025817871, -0.030609131,
    -0.035552979, -0.040634155, -0.045837402, -0.051132202,
    -0.056533813, -0.061996460, -0.067520142, -0.073059082,
    -0.078628540, -0.084182739, -0.089706421, -0.095169067,
    -0.100540161, -0.105819702, -0.110946655, -0.115921021,
    -0.120697021, -0.125259399, -0.129562378, -0.133590698,
    -0.137298584, -0.140670776, -0.143676758, -0.146255493,
    -0.148422241, -0.150115967, -0.151306152, -0.151962280,
    -0.152069092, -0.151596069, -0.150497437, -0.148773193,
    -0.146362305, -0.143264771, -0.139450073, -0.134887695,
    -0.129577637, -0.123474121, -0.116577148, -0.108856201,
    // D[192..255]
     0.100311279,  0.090927124,  0.080688477,  0.069595337,
     0.057617187,  0.044784546,  0.031082153,  0.016510010,
     0.001068115, -0.015228271, -0.032379150, -0.050354004,
    -0.069168091, -0.088775635, -0.109161377, -0.130310059,
    -0.152206421, -0.174789429, -0.198059082, -0.221984863,
    -0.246505737, -0.271591187, -0.297210693, -0.323318481,
    -0.349868774, -0.376800537, -0.404083252, -0.431655884,
    -0.459472656, -0.487472534, -0.515609741, -0.543823242,
    -0.572036743, -0.600219727, -0.628295898, -0.656219482,
    -0.683914185, -0.711318970, -0.738372803, -0.765029907,
    -0.791213989, -0.816864014, -0.841949463, -0.866363525,
    -0.890090942, -0.913055420, -0.935195923, -0.956481934,
    -0.976852417, -0.996246338, -1.014617920, -1.031936646,
    -1.048156738, -1.063217163, -1.077117920, -1.089782715,
    -1.101211548, -1.111373901, -1.120223999, -1.127746582,
    -1.133926392, -1.138763428, -1.142211914, -1.144287109,
    // D[256..319]
     1.144989014,  1.144287109,  1.142211914,  1.138763428,
     1.133926392,  1.127746582,  1.120223999,  1.111373901,
     1.101211548,  1.089782715,  1.077117920,  1.063217163,
     1.048156738,  1.031936646,  1.014617920,  0.996246338,
     0.976852417,  0.956481934,  0.935195923,  0.913055420,
     0.890090942,  0.866363525,  0.841949463,  0.816864014,
     0.791213989,  0.765029907,  0.738372803,  0.711318970,
     0.683914185,  0.656219482,  0.628295898,  0.600219727,
     0.572036743,  0.543823242,  0.515609741,  0.487472534,
     0.459472656,  0.431655884,  0.404083252,  0.376800537,
     0.349868774,  0.323318481,  0.297210693,  0.271591187,
     0.246505737,  0.221984863,  0.198059082,  0.174789429,
     0.152206421,  0.130310059,  0.109161377,  0.088775635,
     0.069168091,  0.050354004,  0.032379150,  0.015228271,
    -0.001068115, -0.016510010, -0.031082153, -0.044784546,
    -0.057617187, -0.069595337, -0.080688477, -0.090927124,
    // D[320..383]
     0.100311279,  0.108856201,  0.116577148,  0.123474121,
     0.129577637,  0.134887695,  0.139450073,  0.143264771,
     0.146362305,  0.148773193,  0.150497437,  0.151596069,
     0.152069092,  0.151962280,  0.151306152,  0.150115967,
     0.148422241,  0.146255493,  0.143676758,  0.140670776,
     0.137298584,  0.133590698,  0.129562378,  0.125259399,
     0.120697021,  0.115921021,  0.110946655,  0.105819702,
     0.100540161,  0.095169067,  0.089706421,  0.084182739,
     0.078628540,  0.073059082,  0.067520142,  0.061996460,
     0.056533813,  0.051132202,  0.045837402,  0.040634155,
     0.035552979,  0.030609131,  0.025817871,  0.021179199,
     0.016708374,  0.012420654,  0.008316040,  0.004394531,
     0.000686646, -0.002822876, -0.006134033, -0.009231567,
    -0.012115479, -0.014801025, -0.017257690, -0.019531250,
    -0.021575928, -0.023422241, -0.025085449, -0.026535034,
    -0.027801514, -0.028884888, -0.029785156, -0.030517578,
    // D[384..447]
     0.031082153,  0.031478882,  0.031738281,  0.031845093,
     0.031814575,  0.031661987,  0.031387329,  0.031005859,
     0.030532837,  0.029937744,  0.029281616,  0.028533936,
     0.027725220,  0.026840210,  0.025909424,  0.024932861,
     0.023910522,  0.022857666,  0.021789551,  0.020690918,
     0.019577026,  0.018463135,  0.017349243,  0.016235352,
     0.015121460,  0.014022827,  0.012939453,  0.011886597,
     0.010848999,  0.009841919,  0.008865356,  0.007919312,
     0.007003784,  0.006118774,  0.005294800,  0.004486084,
     0.003723145,  0.003005981,  0.002334595,  0.001693726,
     0.001098633,  0.000549316,  0.000030518, -0.000442505,
    -0.000869751, -0.001266479, -0.001617432, -0.001937866,
    -0.002227783, -0.002487183, -0.002700806, -0.002883911,
    -0.003051758, -0.003173828, -0.003280640, -0.003372192,
    -0.003417969, -0.003463745, -0.003479004, -0.003479004,
    -0.003463745, -0.003433228, -0.003387451, -0.003326416,
    // D[448..511]
     0.003250122,  0.003173828,  0.003082275,  0.002990723,
     0.002899170,  0.002792358,  0.002685547,  0.002578735,
     0.002456665,  0.002349854,  0.002243042,  0.002120972,
     0.002014160,  0.001907349,  0.001785278,  0.001693726,
     0.001586914,  0.001480103,  0.001388550,  0.001296997,
     0.001205444,  0.001113892,  0.001037598,  0.000961304,
     0.000885010,  0.000808716,  0.000747681,  0.000686646,
     0.000625610,  0.000579834,  0.000534058,  0.000473022,
     0.000442505,  0.000396729,  0.000366211,  0.000320435,
     0.000289917,  0.000259399,  0.000244141,  0.000213623,
     0.000198364,  0.000167847,  0.000152588,  0.000137329,
     0.000122070,  0.000106812,  0.000106812,  0.000091553,
     0.000076294,  0.000076294,  0.000061035,  0.000061035,
     0.000045776,  0.000045776,  0.000030518,  0.000030518,
     0.000030518,  0.000030518,  0.000015259,  0.000015259,
     0.000015259,  0.000015259,  0.000015259,  0.000015259,
];

/// 合成滤波器状态
#[derive(Debug, Clone)]
pub struct SynthContext {
    /// 16 槽 FIFO, 每槽 64 个样本.
    v_vec: [[f32; 64]; 16],
    /// FIFO 前端 (将被下一次写入覆盖的槽位).
    v_front: usize,
}

impl Default for SynthContext {
    fn default() -> Self {
        Self {
            v_vec: [[0.0; 64]; 16],
            v_front: 0,
        }
    }
}

impl SynthContext {
    pub(crate) fn snapshot_state(&self) -> ([[f32; 64]; 16], usize) {
        (self.v_vec, self.v_front)
    }
}

/// 执行多相合成
///
/// 输入: 32 个子带样本 (new_samples)
/// 输出: 32 个 PCM 样本
pub fn synthesis_filter(ctx: &mut SynthContext, new_samples: &[f32; 32], pcm_out: &mut [f32; 32]) {
    let mut d_vec = [0f32; 32];
    let v_vec = &mut ctx.v_vec[ctx.v_front];

    dct32(new_samples, &mut d_vec);

    for (d, s) in v_vec[48 - 15..48].iter_mut().rev().zip(&d_vec[1..16]) {
        *d = -*s;
    }
    for (d, s) in v_vec[49..64].iter_mut().zip(&d_vec[1..16]) {
        *d = -*s;
    }
    for (d, s) in v_vec[17..32].iter_mut().rev().zip(&d_vec[17..32]) {
        *d = -*s;
    }
    for (d, s) in v_vec[1..16].iter_mut().zip(&d_vec[17..32]) {
        *d = *s;
    }

    v_vec[0] = d_vec[16];
    v_vec[32] = -d_vec[16];
    v_vec[48] = -d_vec[0];
    v_vec[16] = 0.0;

    let mut o_vec = [0f32; 32];

    for j in 0..8 {
        let v_start = ctx.v_front + (j << 1);
        let v0 = &ctx.v_vec[v_start & 0xf][0..32];
        let v1 = &ctx.v_vec[(v_start + 1) & 0xf][32..64];
        let k = j << 6;

        for i in 0..32 {
            o_vec[i] += v0[i] * SYNTH_WINDOW[k + i];
            o_vec[i] += v1[i] * SYNTH_WINDOW[k + 32 + i];
        }
    }

    for (o, s) in pcm_out.iter_mut().zip(&o_vec) {
        *o = *s;
    }

    // 向后移动 1 槽, 使下一次写入覆盖最旧槽.
    ctx.v_front = (ctx.v_front + 15) & 0xf;
}

/// Performs a 32-point Discrete Cosine Transform (DCT) using Byeong Gi Lee's fast algorithm
/// without inverse square-root 2 scaling.
#[allow(clippy::excessive_precision)]
fn dct32(x: &[f32; 32], y: &mut [f32; 32]) {
    const COS_16: [f32; 16] = [
        0.500_602_998_235_196_3,
        0.505_470_959_897_543_6,
        0.515_447_309_922_624_6,
        0.531_042_591_089_784_1,
        0.553_103_896_034_444_5,
        0.582_934_968_206_133_9,
        0.622_504_123_035_664_8,
        0.674_808_341_455_005_7,
        0.744_536_271_002_298_6,
        0.839_349_645_415_526_8,
        0.972_568_237_861_960_8,
        1.169_439_933_432_884_7,
        1.484_164_616_314_166_2,
        2.057_781_009_953_410_8,
        3.407_608_418_468_719_0,
        10.190_008_123_548_032_9,
    ];

    const COS_8: [f32; 8] = [
        0.502_419_286_188_155_7,
        0.522_498_614_939_688_9,
        0.566_944_034_816_357_7,
        0.646_821_783_359_990_1,
        0.788_154_623_451_250_2,
        1.060_677_685_990_347_1,
        1.722_447_098_238_334_2,
        5.101_148_618_689_155_3,
    ];

    const COS_4: [f32; 4] = [
        0.509_795_579_104_159_2,
        0.601_344_886_935_045_3,
        0.899_976_223_136_415_6,
        2.562_915_447_741_505_5,
    ];

    const COS_2: [f32; 2] = [0.541_196_100_146_197_0, 1.306_562_964_876_376_4];
    const COS_1: f32 = 0.707_106_781_186_547_5;

    let mut t0 = [
        (x[0] + x[31]),
        (x[1] + x[30]),
        (x[2] + x[29]),
        (x[3] + x[28]),
        (x[4] + x[27]),
        (x[5] + x[26]),
        (x[6] + x[25]),
        (x[7] + x[24]),
        (x[8] + x[23]),
        (x[9] + x[22]),
        (x[10] + x[21]),
        (x[11] + x[20]),
        (x[12] + x[19]),
        (x[13] + x[18]),
        (x[14] + x[17]),
        (x[15] + x[16]),
        (x[0] - x[31]) * COS_16[0],
        (x[1] - x[30]) * COS_16[1],
        (x[2] - x[29]) * COS_16[2],
        (x[3] - x[28]) * COS_16[3],
        (x[4] - x[27]) * COS_16[4],
        (x[5] - x[26]) * COS_16[5],
        (x[6] - x[25]) * COS_16[6],
        (x[7] - x[24]) * COS_16[7],
        (x[8] - x[23]) * COS_16[8],
        (x[9] - x[22]) * COS_16[9],
        (x[10] - x[21]) * COS_16[10],
        (x[11] - x[20]) * COS_16[11],
        (x[12] - x[19]) * COS_16[12],
        (x[13] - x[18]) * COS_16[13],
        (x[14] - x[17]) * COS_16[14],
        (x[15] - x[16]) * COS_16[15],
    ];

    {
        let mut t1 = [
            (t0[0] + t0[15]),
            (t0[1] + t0[14]),
            (t0[2] + t0[13]),
            (t0[3] + t0[12]),
            (t0[4] + t0[11]),
            (t0[5] + t0[10]),
            (t0[6] + t0[9]),
            (t0[7] + t0[8]),
            (t0[0] - t0[15]) * COS_8[0],
            (t0[1] - t0[14]) * COS_8[1],
            (t0[2] - t0[13]) * COS_8[2],
            (t0[3] - t0[12]) * COS_8[3],
            (t0[4] - t0[11]) * COS_8[4],
            (t0[5] - t0[10]) * COS_8[5],
            (t0[6] - t0[9]) * COS_8[6],
            (t0[7] - t0[8]) * COS_8[7],
        ];

        {
            let mut t2 = [
                (t1[0] + t1[7]),
                (t1[1] + t1[6]),
                (t1[2] + t1[5]),
                (t1[3] + t1[4]),
                (t1[0] - t1[7]) * COS_4[0],
                (t1[1] - t1[6]) * COS_4[1],
                (t1[2] - t1[5]) * COS_4[2],
                (t1[3] - t1[4]) * COS_4[3],
            ];

            {
                let mut t3 = [
                    (t2[0] + t2[3]),
                    (t2[1] + t2[2]),
                    (t2[0] - t2[3]) * COS_2[0],
                    (t2[1] - t2[2]) * COS_2[1],
                ];

                let t4 = [(t3[0] + t3[1]), (t3[0] - t3[1]) * COS_1];
                t3[0] = t4[0];
                t3[1] = t4[1];

                let t4 = [(t3[2] + t3[3]), (t3[2] - t3[3]) * COS_1];
                t3[2] = t4[0];
                t3[3] = t4[1];

                t2[0] = t3[0];
                t2[1] = t3[2] + t3[3];
                t2[2] = t3[1];
                t2[3] = t3[3];
            }

            {
                let mut t3 = [
                    (t2[4] + t2[7]),
                    (t2[5] + t2[6]),
                    (t2[4] - t2[7]) * COS_2[0],
                    (t2[5] - t2[6]) * COS_2[1],
                ];

                let t4 = [(t3[0] + t3[1]), (t3[0] - t3[1]) * COS_1];
                t3[0] = t4[0];
                t3[1] = t4[1];

                let t4 = [(t3[2] + t3[3]), (t3[2] - t3[3]) * COS_1];
                t3[2] = t4[0];
                t3[3] = t4[1];

                t2[4] = t3[0];
                t2[5] = t3[2] + t3[3];
                t2[6] = t3[1];
                t2[7] = t3[3];
            }

            for i in 0..3 {
                t1[i << 1] = t2[i];
                t1[(i << 1) + 1] = t2[4 + i] + t2[5 + i];
            }
            t1[6] = t2[3];
            t1[7] = t2[7];
        }

        {
            let mut t2 = [
                (t1[8] + t1[15]),
                (t1[9] + t1[14]),
                (t1[10] + t1[13]),
                (t1[11] + t1[12]),
                (t1[8] - t1[15]) * COS_4[0],
                (t1[9] - t1[14]) * COS_4[1],
                (t1[10] - t1[13]) * COS_4[2],
                (t1[11] - t1[12]) * COS_4[3],
            ];

            {
                let mut t3 = [
                    (t2[0] + t2[3]),
                    (t2[1] + t2[2]),
                    (t2[0] - t2[3]) * COS_2[0],
                    (t2[1] - t2[2]) * COS_2[1],
                ];

                let t4 = [(t3[0] + t3[1]), (t3[0] - t3[1]) * COS_1];
                t3[0] = t4[0];
                t3[1] = t4[1];

                let t4 = [(t3[2] + t3[3]), (t3[2] - t3[3]) * COS_1];
                t3[2] = t4[0];
                t3[3] = t4[1];

                t2[0] = t3[0];
                t2[1] = t3[2] + t3[3];
                t2[2] = t3[1];
                t2[3] = t3[3];
            }

            {
                let mut t3 = [
                    (t2[4] + t2[7]),
                    (t2[5] + t2[6]),
                    (t2[4] - t2[7]) * COS_2[0],
                    (t2[5] - t2[6]) * COS_2[1],
                ];

                let t4 = [(t3[0] + t3[1]), (t3[0] - t3[1]) * COS_1];
                t3[0] = t4[0];
                t3[1] = t4[1];

                let t4 = [(t3[2] + t3[3]), (t3[2] - t3[3]) * COS_1];
                t3[2] = t4[0];
                t3[3] = t4[1];

                t2[4] = t3[0];
                t2[5] = t3[2] + t3[3];
                t2[6] = t3[1];
                t2[7] = t3[3];
            }

            for i in 0..3 {
                t1[8 + (i << 1)] = t2[i];
                t1[8 + (i << 1) + 1] = t2[4 + i] + t2[5 + i];
            }
            t1[14] = t2[3];
            t1[15] = t2[7];
        }

        for i in 0..7 {
            t0[i << 1] = t1[i];
            t0[(i << 1) + 1] = t1[8 + i] + t1[9 + i];
        }
        t0[14] = t1[7];
        t0[15] = t1[15];
    }

    {
        let mut t1 = [
            (t0[16] + t0[31]),
            (t0[17] + t0[30]),
            (t0[18] + t0[29]),
            (t0[19] + t0[28]),
            (t0[20] + t0[27]),
            (t0[21] + t0[26]),
            (t0[22] + t0[25]),
            (t0[23] + t0[24]),
            (t0[16] - t0[31]) * COS_8[0],
            (t0[17] - t0[30]) * COS_8[1],
            (t0[18] - t0[29]) * COS_8[2],
            (t0[19] - t0[28]) * COS_8[3],
            (t0[20] - t0[27]) * COS_8[4],
            (t0[21] - t0[26]) * COS_8[5],
            (t0[22] - t0[25]) * COS_8[6],
            (t0[23] - t0[24]) * COS_8[7],
        ];

        {
            let mut t2 = [
                (t1[0] + t1[7]),
                (t1[1] + t1[6]),
                (t1[2] + t1[5]),
                (t1[3] + t1[4]),
                (t1[0] - t1[7]) * COS_4[0],
                (t1[1] - t1[6]) * COS_4[1],
                (t1[2] - t1[5]) * COS_4[2],
                (t1[3] - t1[4]) * COS_4[3],
            ];

            {
                let mut t3 = [
                    (t2[0] + t2[3]),
                    (t2[1] + t2[2]),
                    (t2[0] - t2[3]) * COS_2[0],
                    (t2[1] - t2[2]) * COS_2[1],
                ];

                let t4 = [(t3[0] + t3[1]), (t3[0] - t3[1]) * COS_1];
                t3[0] = t4[0];
                t3[1] = t4[1];

                let t4 = [(t3[2] + t3[3]), (t3[2] - t3[3]) * COS_1];
                t3[2] = t4[0];
                t3[3] = t4[1];

                t2[0] = t3[0];
                t2[1] = t3[2] + t3[3];
                t2[2] = t3[1];
                t2[3] = t3[3];
            }

            {
                let mut t3 = [
                    (t2[4] + t2[7]),
                    (t2[5] + t2[6]),
                    (t2[4] - t2[7]) * COS_2[0],
                    (t2[5] - t2[6]) * COS_2[1],
                ];

                let t4 = [(t3[0] + t3[1]), (t3[0] - t3[1]) * COS_1];
                t3[0] = t4[0];
                t3[1] = t4[1];

                let t4 = [(t3[2] + t3[3]), (t3[2] - t3[3]) * COS_1];
                t3[2] = t4[0];
                t3[3] = t4[1];

                t2[4] = t3[0];
                t2[5] = t3[2] + t3[3];
                t2[6] = t3[1];
                t2[7] = t3[3];
            }

            for i in 0..3 {
                t1[i << 1] = t2[i];
                t1[(i << 1) + 1] = t2[4 + i] + t2[5 + i];
            }
            t1[6] = t2[3];
            t1[7] = t2[7];
        }

        {
            let mut t2 = [
                (t1[8] + t1[15]),
                (t1[9] + t1[14]),
                (t1[10] + t1[13]),
                (t1[11] + t1[12]),
                (t1[8] - t1[15]) * COS_4[0],
                (t1[9] - t1[14]) * COS_4[1],
                (t1[10] - t1[13]) * COS_4[2],
                (t1[11] - t1[12]) * COS_4[3],
            ];

            {
                let mut t3 = [
                    (t2[0] + t2[3]),
                    (t2[1] + t2[2]),
                    (t2[0] - t2[3]) * COS_2[0],
                    (t2[1] - t2[2]) * COS_2[1],
                ];

                let t4 = [(t3[0] + t3[1]), (t3[0] - t3[1]) * COS_1];
                t3[0] = t4[0];
                t3[1] = t4[1];

                let t4 = [(t3[2] + t3[3]), (t3[2] - t3[3]) * COS_1];
                t3[2] = t4[0];
                t3[3] = t4[1];

                t2[0] = t3[0];
                t2[1] = t3[2] + t3[3];
                t2[2] = t3[1];
                t2[3] = t3[3];
            }

            {
                let mut t3 = [
                    (t2[4] + t2[7]),
                    (t2[5] + t2[6]),
                    (t2[4] - t2[7]) * COS_2[0],
                    (t2[5] - t2[6]) * COS_2[1],
                ];

                let t4 = [(t3[0] + t3[1]), (t3[0] - t3[1]) * COS_1];
                t3[0] = t4[0];
                t3[1] = t4[1];

                let t4 = [(t3[2] + t3[3]), (t3[2] - t3[3]) * COS_1];
                t3[2] = t4[0];
                t3[3] = t4[1];

                t2[4] = t3[0];
                t2[5] = t3[2] + t3[3];
                t2[6] = t3[1];
                t2[7] = t3[3];
            }

            for i in 0..3 {
                t1[8 + (i << 1)] = t2[i];
                t1[8 + (i << 1) + 1] = t2[4 + i] + t2[5 + i];
            }
            t1[14] = t2[3];
            t1[15] = t2[7];
        }

        for i in 0..7 {
            t0[16 + (i << 1)] = t1[i];
            t0[16 + (i << 1) + 1] = t1[8 + i] + t1[9 + i];
        }
        t0[30] = t1[7];
        t0[31] = t1[15];
    }

    for i in 0..15 {
        y[i << 1] = t0[i];
        y[(i << 1) + 1] = t0[16 + i] + t0[17 + i];
    }
    y[30] = t0[15];
    y[31] = t0[31];
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::f64::consts::PI as PI64;

    /// 使用 f64 精度计算参考 matrixing 输出
    fn reference_matrixing(samples: &[f32; 32]) -> [f64; 64] {
        let mut v = [0.0f64; 64];
        for i in 0..64 {
            let mut sum = 0.0f64;
            for k in 0..32 {
                let angle = PI64 / 64.0 * (16.0 + i as f64) * (2.0 * k as f64 + 1.0);
                sum += samples[k] as f64 * angle.cos();
            }
            v[i] = sum;
        }
        v
    }

    /// 使用 f64 精度计算参考 PCM 输出 (完整的标准算法)
    fn reference_synthesis(v_history: &[[f64; 64]], window: &[f32; 512]) -> [f64; 32] {
        // 构建 U 向量
        let mut u = [0.0f64; 512];
        for i in 0..8 {
            for j in 0..32 {
                let slot_even = i * 2;
                let slot_odd = i * 2 + 1;
                u[64 * i + j] = if slot_even < v_history.len() {
                    v_history[slot_even][j]
                } else {
                    0.0
                };
                u[64 * i + 32 + j] = if slot_odd < v_history.len() {
                    v_history[slot_odd][32 + j]
                } else {
                    0.0
                };
            }
        }

        // 窗口加权 + 累加
        let mut pcm = [0.0f64; 32];
        for j in 0..32 {
            let mut sum = 0.0f64;
            for i in 0..16 {
                let idx = j + 32 * i;
                sum += window[idx] as f64 * u[idx];
            }
            pcm[j] = sum;
        }
        pcm
    }

    #[test]
    fn test_synthesis_impulse_subband0() {
        // 测试: 仅子带 0 有信号 (S[0]=1.0, 其余为 0)
        let mut input = [0.0f32; 32];
        input[0] = 1.0;

        let mut ctx = SynthContext::default();
        let mut pcm_out = [0.0f32; 32];
        synthesis_filter(&mut ctx, &input, &mut pcm_out);

        // 参考计算
        let ref_v = reference_matrixing(&input);
        let ref_pcm = reference_synthesis(&[ref_v], &SYNTH_WINDOW);

        // 对比
        let mut max_err = 0.0f64;
        for i in 0..32 {
            let err = (pcm_out[i] as f64 - ref_pcm[i]).abs();
            if err > max_err {
                max_err = err;
            }
        }

        assert!(max_err < 1e-4, "合成滤波器误差过大: {:.6}", max_err);
    }

    #[test]
    fn test_synthesis_all_ones() {
        // 测试: 所有子带均为 1.0
        let input = [1.0f32; 32];

        let mut ctx = SynthContext::default();
        let mut pcm_out = [0.0f32; 32];
        synthesis_filter(&mut ctx, &input, &mut pcm_out);

        // 参考计算
        let ref_v = reference_matrixing(&input);
        let ref_pcm = reference_synthesis(&[ref_v], &SYNTH_WINDOW);

        let mut max_err = 0.0f64;
        for i in 0..32 {
            let err = (pcm_out[i] as f64 - ref_pcm[i]).abs();
            if err > max_err {
                max_err = err;
            }
        }

        assert!(max_err < 1e-4, "合成滤波器误差过大: {:.6}", max_err);
    }

    #[test]
    fn test_synthesis_multi_frame() {
        // 测试: 多次调用合成滤波器 (验证 V 缓冲区管理)
        let mut ctx = SynthContext::default();
        let mut v_history: Vec<[f64; 64]> = Vec::new();

        let inputs: [[f32; 32]; 4] = [
            {
                let mut a = [0.0; 32];
                a[0] = 1.0;
                a[1] = 0.5;
                a
            },
            {
                let mut a = [0.0; 32];
                a[0] = -0.3;
                a[5] = 0.8;
                a
            },
            {
                let mut a = [0.0; 32];
                a[10] = 1.0;
                a[20] = -0.7;
                a
            },
            {
                let mut a = [0.0; 32];
                a[31] = 1.0;
                a
            },
        ];

        for (frame, input) in inputs.iter().enumerate() {
            let mut pcm_out = [0.0f32; 32];
            synthesis_filter(&mut ctx, input, &mut pcm_out);

            // 参考: 每次调用, 新的 V 放到最前面
            let ref_v = reference_matrixing(input);
            v_history.insert(0, ref_v);

            // 使用 v_history 构建 U 并计算参考 PCM
            // v_history[0] = 最新, v_history[1] = 第二新, ...
            // U[64*i + j] = v_history[2*i][j]      (偶数槽, 前 32)
            // U[64*i + 32 + j] = v_history[2*i+1][32+j]  (奇数槽, 后 32)
            let ref_pcm = reference_synthesis(&v_history, &SYNTH_WINDOW);

            let mut max_err = 0.0f64;
            for i in 0..32 {
                let err = (pcm_out[i] as f64 - ref_pcm[i]).abs();
                if err > max_err {
                    max_err = err;
                }
            }

            assert!(
                max_err < 1e-3,
                "Frame {} 合成滤波器误差过大: {:.6}",
                frame,
                max_err
            );
        }
    }
}
