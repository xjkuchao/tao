//! CABAC (Context-Adaptive Binary Arithmetic Coding) 引擎.
//!
//! 实现 H.264 CABAC 二进制算术解码的核心逻辑.

use super::cabac_init_ext::{CABAC_INIT_I_EXT_460_1011, CABAC_INIT_PB0_EXT_460_1011};
use super::cabac_init_pb::{CABAC_INIT_PB1, CABAC_INIT_PB2};

/// CABAC 上下文模型
#[derive(Clone, Copy)]
pub struct CabacCtx {
    /// 概率状态索引 (0-63)
    pub state: u8,
    /// 最大概率符号 (0 或 1)
    pub mps: u8,
}

/// CABAC 解码器
pub struct CabacDecoder<'a> {
    data: &'a [u8],
    bit_pos: usize,
    raw_pos: usize,
    cod_i_range: u32,
    cod_i_offset: u32,
}

impl<'a> CabacDecoder<'a> {
    fn read_input_bit(&mut self) -> u32 {
        let byte = self.data.get(self.bit_pos >> 3).copied().unwrap_or(0);
        let shift = 7usize.saturating_sub(self.bit_pos & 7);
        self.bit_pos = self.bit_pos.saturating_add(1);
        u32::from((byte >> shift) & 1)
    }

    fn read_input_bits(&mut self, n: usize) -> u32 {
        let mut out = 0u32;
        for _ in 0..n {
            out = (out << 1) | self.read_input_bit();
        }
        out
    }

    fn renormalize(&mut self) {
        while self.cod_i_range < 256 {
            self.cod_i_range <<= 1;
            self.cod_i_offset = (self.cod_i_offset << 1) | self.read_input_bit();
        }
    }

    fn init_decoder_from(&mut self, start_byte: usize) {
        self.bit_pos = start_byte.saturating_mul(8);
        self.raw_pos = start_byte;
        self.cod_i_range = 510;
        self.cod_i_offset = self.read_input_bits(9);
    }

    /// 从字节切片初始化 CABAC 解码器
    pub fn new(data: &'a [u8]) -> Self {
        let mut out = Self {
            data,
            bit_pos: 0,
            raw_pos: 0,
            cod_i_range: 510,
            cod_i_offset: 0,
        };
        out.init_decoder_from(0);
        out
    }

    /// 带上下文模型的算术解码 (regular mode)
    pub fn decode_decision(&mut self, ctx: &mut CabacCtx) -> u32 {
        let q_idx = ((self.cod_i_range >> 6) & 3) as usize;
        let s = ctx.state as usize;
        let range_lps = RANGE_TAB_LPS[s][q_idx] as u32;
        self.cod_i_range -= range_lps;

        if self.cod_i_offset < self.cod_i_range {
            ctx.state = TRANS_IDX_MPS[s];
            self.renormalize();
            ctx.mps as u32
        } else {
            self.cod_i_offset -= self.cod_i_range;
            self.cod_i_range = range_lps;
            let symbol = 1 - ctx.mps as u32;
            if ctx.state == 0 {
                ctx.mps = 1 - ctx.mps;
            }
            ctx.state = TRANS_IDX_LPS[s];
            self.renormalize();
            symbol
        }
    }

    /// 旁路模式解码 (等概率)
    pub fn decode_bypass(&mut self) -> u32 {
        self.cod_i_offset = (self.cod_i_offset << 1) | self.read_input_bit();
        if self.cod_i_offset >= self.cod_i_range {
            self.cod_i_offset -= self.cod_i_range;
            1
        } else {
            0
        }
    }

    /// 终止模式解码 (end_of_slice_flag)
    pub fn decode_terminate(&mut self) -> u32 {
        self.cod_i_range = self.cod_i_range.saturating_sub(2);
        if self.cod_i_offset >= self.cod_i_range {
            1
        } else {
            self.renormalize();
            0
        }
    }

    /// 对齐到 I_PCM 原始样本起点
    pub fn align_to_byte_boundary(&mut self) {
        // 对齐语义对齐 FFmpeg:
        // ptr = bytestream; if (low & 1) ptr--;
        // 这里以当前按字节消费位置为基准, 必要时回退 1 字节.
        let mut ptr = self.bit_pos >> 3;
        if (self.cod_i_offset & 1) != 0 {
            ptr = ptr.saturating_sub(1);
        }
        self.raw_pos = ptr;
    }

    /// 读取原始字节 (用于 I_PCM 样本读取)
    pub fn read_raw_byte(&mut self) -> u8 {
        let out = self.data.get(self.raw_pos).copied().unwrap_or(0);
        self.raw_pos = self.raw_pos.saturating_add(1);
        out
    }

    /// I_PCM 结束后重启 CABAC 引擎
    pub fn restart_engine(&mut self) {
        self.init_decoder_from(self.raw_pos);
    }
}

/// 初始化 CABAC 上下文模型数组 (I-slice)
pub fn init_contexts_i_slice(qp: i32) -> Vec<CabacCtx> {
    let mut ctxs = vec![CabacCtx { state: 0, mps: 0 }; 1024];
    for (i, &(m, n)) in CABAC_INIT_I.iter().enumerate() {
        if i < ctxs.len() {
            ctxs[i] = init_single_ctx(m, n, qp);
        }
    }
    for (i, &(m, n)) in CABAC_INIT_I_EXT_277_459.iter().enumerate() {
        let idx = 277 + i;
        if idx < ctxs.len() {
            ctxs[idx] = init_single_ctx(m, n, qp);
        }
    }
    for (i, &(m, n)) in CABAC_INIT_I_EXT_460_1011.iter().enumerate() {
        let idx = 460 + i;
        if idx < ctxs.len() {
            ctxs[idx] = init_single_ctx(m, n, qp);
        }
    }
    for (i, &(m, n)) in CABAC_INIT_I_EXT_1012_1023.iter().enumerate() {
        let idx = 1012 + i;
        if idx < ctxs.len() {
            ctxs[idx] = init_single_ctx(m, n, qp);
        }
    }
    ctxs
}

/// 初始化 CABAC 上下文模型数组 (P/B-slice, cabac_init_idc=0/1/2)
pub fn init_contexts_pb_slice(qp: i32, cabac_init_idc: u8) -> Vec<CabacCtx> {
    let idc = cabac_init_idc.min(2);

    if idc == 1 {
        let mut ctxs = vec![CabacCtx { state: 0, mps: 0 }; 1024];
        for (i, &(m, n)) in CABAC_INIT_PB1.iter().enumerate() {
            if i < ctxs.len() {
                ctxs[i] = init_single_ctx(m, n, qp);
            }
        }
        return ctxs;
    }
    if idc == 2 {
        let mut ctxs = vec![CabacCtx { state: 0, mps: 0 }; 1024];
        for (i, &(m, n)) in CABAC_INIT_PB2.iter().enumerate() {
            if i < ctxs.len() {
                ctxs[i] = init_single_ctx(m, n, qp);
            }
        }
        return ctxs;
    }

    let mut ctxs = vec![CabacCtx { state: 0, mps: 0 }; 1024];
    for (i, &(m, n)) in CABAC_INIT_PB0.iter().enumerate() {
        if i < ctxs.len() {
            ctxs[i] = init_single_ctx(m, n, qp);
        }
    }
    for (i, &(m, n)) in CABAC_INIT_PB0_EXT_277_459.iter().enumerate() {
        let idx = 277 + i;
        if idx < ctxs.len() {
            ctxs[idx] = init_single_ctx(m, n, qp);
        }
    }
    for (i, &(m, n)) in CABAC_INIT_PB0_EXT_460_1011.iter().enumerate() {
        let idx = 460 + i;
        if idx < ctxs.len() {
            ctxs[idx] = init_single_ctx(m, n, qp);
        }
    }
    for (i, &(m, n)) in CABAC_INIT_PB0_EXT_1012_1023.iter().enumerate() {
        let idx = 1012 + i;
        if idx < ctxs.len() {
            ctxs[idx] = init_single_ctx(m, n, qp);
        }
    }
    ctxs
}

/// 从 (m, n) 和 QP 计算单个上下文的初始状态
fn init_single_ctx(m: i8, n: i8, qp: i32) -> CabacCtx {
    let pre = (((m as i32) * qp.clamp(0, 51)) >> 4) + n as i32;
    let pre = pre.clamp(1, 126);
    if pre <= 63 {
        CabacCtx {
            state: (63 - pre) as u8,
            mps: 0,
        }
    } else {
        CabacCtx {
            state: (pre - 64) as u8,
            mps: 1,
        }
    }
}

// ============================================================
// CABAC 算术解码表 (H.264 规范 Table 9-48, 9-49, 9-50)
// ============================================================

/// rangeTabLPS[pStateIdx][qCodIRangeIdx] (Table 9-48)
#[rustfmt::skip]
const RANGE_TAB_LPS: [[u8; 4]; 64] = [
    [128,176,208,240],[128,167,197,227],[128,158,187,216],[123,150,178,205],
    [116,142,169,195],[111,135,160,185],[105,128,152,175],[100,122,144,166],
    [ 95,116,137,158],[ 90,110,130,150],[ 85,104,123,142],[ 81, 99,117,135],
    [ 77, 94,111,128],[ 73, 89,105,122],[ 69, 85,100,116],[ 66, 80, 95,110],
    [ 62, 76, 90,104],[ 59, 72, 86, 99],[ 56, 69, 81, 94],[ 53, 65, 77, 89],
    [ 51, 62, 73, 85],[ 48, 59, 69, 80],[ 46, 56, 66, 76],[ 43, 53, 63, 72],
    [ 41, 50, 59, 69],[ 39, 48, 56, 65],[ 37, 45, 54, 62],[ 35, 43, 51, 59],
    [ 33, 41, 48, 56],[ 32, 39, 46, 53],[ 30, 37, 43, 50],[ 29, 35, 41, 48],
    [ 27, 33, 39, 45],[ 26, 31, 37, 43],[ 24, 30, 35, 41],[ 23, 28, 33, 39],
    [ 22, 27, 32, 37],[ 21, 26, 30, 35],[ 20, 24, 29, 33],[ 19, 23, 27, 31],
    [ 18, 22, 26, 30],[ 17, 21, 25, 28],[ 16, 20, 23, 27],[ 15, 19, 22, 25],
    [ 14, 18, 21, 24],[ 14, 17, 20, 23],[ 13, 16, 19, 22],[ 12, 15, 18, 21],
    [ 12, 14, 17, 20],[ 11, 14, 16, 19],[ 11, 13, 15, 18],[ 10, 12, 15, 17],
    [ 10, 12, 14, 16],[  9, 11, 13, 15],[  9, 11, 12, 14],[  8, 10, 12, 14],
    [  8,  9, 11, 13],[  7,  9, 11, 12],[  7,  9, 10, 12],[  7,  8, 10, 11],
    [  6,  8,  9, 11],[  6,  7,  9, 10],[  6,  7,  8, 10],[  2,  2,  2,  2],
];

/// transIdxLPS[pStateIdx] (Table 9-49): LPS 状态转移
#[rustfmt::skip]
const TRANS_IDX_LPS: [u8; 64] = [
     0, 0, 1, 2, 2, 4, 4, 5, 6, 7, 8, 9, 9,11,11,12,
    13,13,15,15,16,16,18,18,19,19,21,21,22,22,23,24,
    24,25,26,26,27,27,28,29,29,30,30,30,31,32,32,33,
    33,33,34,34,35,35,35,36,36,36,37,37,37,38,38,63,
];

/// transIdxMPS[pStateIdx] (Table 9-50): MPS 状态转移
#[rustfmt::skip]
const TRANS_IDX_MPS: [u8; 64] = [
     1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,
    17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,
    33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
    49,50,51,52,53,54,55,56,57,58,59,60,61,62,62,63,
];

// ============================================================
// 上下文初始化表 (m, n) — 来自 H.264 规范 Table 9-12 ~ 9-23
// ============================================================

/// I-slice 上下文初始化表 (ctxIdx 0..276)
#[rustfmt::skip]
const CABAC_INIT_I: [(i8, i8); 277] = [
    // 0-10
    (20,-15),(2,54),(3,74),(20,-15),(2,54),(3,74),(-28,127),(-23,104),(-6,53),(-1,54),(7,51),
    // 11-23 (unused for I)
    (0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),
    // 24-39
    (0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),
    // 40-59
    (0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),(0,0),
    (0,0),(0,0),(0,0),(0,0),(0,0),(0,0),
    // 60-69
    (0,41),(0,63),(0,63),(0,63),(-9,83),(4,86),(0,97),(-7,72),(13,41),(3,62),
    // 70-87
    (0,11),(1,55),(0,69),(-17,127),(-13,102),(0,82),(-7,74),(-21,107),
    (-27,127),(-31,127),(-24,127),(-18,95),(-27,127),(-21,114),(-30,127),(-17,123),(-12,115),(-16,122),
    // 88-104
    (-11,115),(-12,63),(-2,68),(-15,84),(-13,104),(-3,70),(-8,93),(-10,90),
    (-30,127),(-1,74),(-6,97),(-7,91),(-20,127),(-4,56),(-5,82),(-7,76),(-22,125),
    // 105-135
    (-7,93),(-11,87),(-3,77),(-5,71),(-4,63),(-4,68),(-12,84),(-7,62),
    (-7,65),(8,61),(5,56),(-2,66),(1,64),(0,61),(-2,78),(1,50),
    (7,52),(10,35),(0,44),(11,38),(1,45),(0,46),(5,44),(31,17),
    (1,51),(7,50),(28,19),(16,33),(14,62),(-13,108),(-15,100),
    // 136-165
    (-13,101),(-13,91),(-12,94),(-10,88),(-16,84),(-10,86),(-7,83),(-13,87),
    (-19,94),(1,70),(0,72),(-5,74),(18,59),(-8,102),(-15,100),(0,95),
    (-4,75),(2,72),(-11,75),(-3,71),(15,46),(-13,69),(0,62),(0,65),
    (21,37),(-15,72),(9,57),(16,54),(0,62),(12,72),
    // 166-196
    (24,0),(15,9),(8,25),(13,18),(15,9),(13,19),(10,37),(12,18),
    (6,29),(20,33),(15,30),(4,45),(1,58),(0,62),(7,61),(12,38),
    (11,45),(15,39),(11,42),(13,44),(16,45),(12,41),(10,49),(30,34),
    (18,42),(10,55),(17,51),(17,46),(0,89),(26,-19),(22,-17),
    // 197-226
    (26,-17),(30,-25),(28,-20),(33,-23),(37,-27),(33,-23),(40,-28),(38,-17),
    (33,-11),(40,-15),(41,-6),(38,1),(41,17),(30,-6),(27,3),(26,22),
    (37,-16),(35,-4),(38,-8),(38,-3),(37,3),(38,5),(42,0),(35,16),
    (39,22),(14,48),(27,37),(21,60),(12,68),(2,97),
    // 227-251
    (-3,71),(-6,42),(-5,50),(-3,54),(-2,62),(0,58),(1,63),(-2,72),
    (-1,74),(-9,91),(-5,67),(-5,27),(-3,39),(-2,44),(0,46),(-16,64),
    (-8,68),(-10,78),(-6,77),(-10,86),(-12,92),(-15,55),(-10,60),(-6,62),(-4,65),
    // 252-275
    (-12,73),(-8,76),(-7,80),(-9,88),(-17,110),(-11,97),(-20,84),(-11,79),
    (-6,73),(-4,74),(-13,86),(-13,96),(-11,97),(-19,117),(-8,78),(-5,33),
    (-4,48),(-2,53),(-3,62),(-13,71),(-10,79),(-12,86),(-13,90),(-14,97),
    // 276
    (0,0),
];

/// P-slice (cabac_init_idc=0) 上下文初始化表 (ctxIdx 0..276)
#[rustfmt::skip]
const CABAC_INIT_PB0: [(i8, i8); 277] = [
    // 0-10
    (20,-15),(2,54),(3,74),(20,-15),(2,54),(3,74),(-28,127),(-23,104),(-6,53),(-1,54),(7,51),
    // 11-23
    (23,33),(23,2),(21,0),(1,9),(0,49),(-37,118),(5,57),(-13,78),(-11,65),(1,62),(12,49),(-4,73),(17,50),
    // 24-39
    (18,64),(9,43),(29,0),(26,67),(16,90),(9,104),(-46,127),(-20,104),
    (1,67),(-13,78),(-11,65),(1,62),(-6,86),(-17,95),(-6,61),(9,45),
    // 40-53
    (-3,69),(-6,81),(-11,96),(6,55),(7,67),(-5,86),(2,88),(0,58),
    (-3,76),(-10,94),(5,54),(4,69),(-3,81),(0,88),
    // 54-59
    (-7,67),(-5,74),(-4,74),(-5,80),(-7,72),(1,58),
    // 60-69
    (0,41),(0,63),(0,63),(0,63),(-9,83),(4,86),(0,97),(-7,72),(13,41),(3,62),
    // 70-87 (P-slice has 88-70+1=18 + extra entries)
    (0,45),(-4,78),(-3,96),(-27,126),(-28,98),(-25,101),(-23,67),(-28,82),
    (-20,94),(-16,83),(-22,110),(-21,91),(-18,102),(-13,93),(-29,127),(-7,92),(-5,89),(-7,96),
    // 88-104
    (-13,108),(-3,46),(-1,65),(-1,57),(-9,93),(-3,74),(-9,92),(-8,87),
    (-23,126),(5,54),(6,60),(6,59),(6,69),(-1,48),(0,68),(-4,69),(-8,88),
    // 105-135
    (-2,85),(-6,78),(-1,75),(-7,77),(2,54),(5,50),(-3,68),(1,50),
    (6,42),(-4,81),(1,63),(-4,70),(0,67),(2,57),(-2,76),(11,35),
    (4,64),(1,61),(11,35),(18,25),(12,24),(13,29),(13,36),(-10,93),
    (-7,73),(-2,73),(13,46),(9,49),(-7,100),(9,53),(2,53),
    // 136-165
    (5,53),(-2,61),(0,56),(0,56),(-13,63),(-5,60),(-1,62),(4,57),
    (-6,69),(4,57),(14,39),(4,51),(13,68),(3,64),(1,61),(9,63),
    (7,50),(16,39),(5,44),(4,52),(11,48),(-5,60),(-1,59),(0,59),
    (22,33),(5,44),(14,43),(-1,78),(0,60),(9,69),
    // 166-196
    (11,28),(2,40),(3,44),(0,49),(0,46),(2,44),(2,51),(0,47),
    (4,39),(2,62),(6,46),(0,54),(3,54),(2,58),(4,63),(6,51),
    (6,57),(7,53),(6,52),(6,55),(11,45),(14,36),(8,53),(-1,82),
    (7,55),(-3,78),(15,46),(22,31),(-1,84),(25,7),(30,-7),
    // 197-226
    (28,3),(28,4),(32,0),(34,-1),(30,6),(30,6),(32,9),(31,19),
    (26,27),(26,30),(37,20),(28,34),(17,70),(1,67),(5,59),(9,67),
    (16,30),(18,32),(18,35),(22,29),(24,31),(23,38),(18,43),(20,41),
    (11,63),(9,59),(9,64),(-1,94),(-2,89),(-9,108),
    // 227-251
    (-6,76),(-2,44),(0,45),(0,52),(-3,64),(-2,59),(-4,70),(-4,75),
    (-8,82),(-17,102),(-9,77),(3,24),(0,42),(0,48),(0,55),(-6,59),
    (-7,71),(-12,83),(-11,87),(-30,119),(1,58),(-3,29),(-1,36),(1,38),(2,43),
    // 252-275
    (-6,55),(0,58),(0,64),(-3,74),(-10,90),(0,70),(-4,29),(5,31),
    (7,42),(1,59),(-2,58),(-3,72),(-3,81),(-11,97),(0,58),(8,5),
    (10,14),(14,18),(13,27),(2,40),(0,58),(-3,70),(-6,79),(-8,85),
    // 276
    (0,0),
];

/// I-slice 上下文初始化扩展表 (ctxIdx 277..459).
///
/// 取自 FFmpeg `cabac_context_init_I`.
#[rustfmt::skip]
const CABAC_INIT_I_EXT_277_459: [(i8, i8); 183] = [
    (-6,93), (-6,84), (-8,79), (0,66), (-1,71), (0,62), (-2,60), (-2,59),
    (-5,75), (-3,62), (-4,58), (-9,66), (-1,79), (0,71), (3,68), (10,44),
    (-7,62), (15,36), (14,40), (16,27), (12,29), (1,44), (20,36), (18,32),
    (5,42), (1,48), (10,62), (17,46), (9,64), (-12,104), (-11,97), (-16,96),
    (-7,88), (-8,85), (-7,85), (-9,85), (-13,88), (4,66), (-3,77), (-3,76),
    (-6,76), (10,58), (-1,76), (-1,83), (-7,99), (-14,95), (2,95), (0,76),
    (-5,74), (0,70), (-11,75), (1,68), (0,65), (-14,73), (3,62), (4,62),
    (-1,68), (-13,75), (11,55), (5,64), (12,70), (15,6), (6,19), (7,16),
    (12,14), (18,13), (13,11), (13,15), (15,16), (12,23), (13,23), (15,20),
    (14,26), (14,44), (17,40), (17,47), (24,17), (21,21), (25,22), (31,27),
    (22,29), (19,35), (14,50), (10,57), (7,63), (-2,77), (-4,82), (-3,94),
    (9,69), (-12,109), (36,-35), (36,-34), (32,-26), (37,-30), (44,-32), (34,-18),
    (34,-15), (40,-15), (33,-7), (35,-5), (33,0), (38,2), (33,13), (23,35),
    (13,58), (29,-3), (26,0), (22,30), (31,-7), (35,-15), (34,-3), (34,3),
    (36,-1), (34,5), (32,11), (35,5), (34,12), (39,11), (30,29), (34,26),
    (29,39), (19,66), (31,21), (31,31), (25,50), (-17,120), (-20,112), (-18,114),
    (-11,85), (-15,92), (-14,89), (-26,71), (-15,81), (-14,80), (0,68), (-14,70),
    (-24,56), (-23,68), (-24,50), (-11,74), (23,-13), (26,-13), (40,-15), (49,-14),
    (44,3), (45,6), (44,34), (33,54), (19,82), (-3,75), (-1,23), (1,34),
    (1,43), (0,54), (-2,55), (0,61), (1,64), (0,68), (-9,92), (-14,106),
    (-13,97), (-15,90), (-12,90), (-18,88), (-10,73), (-9,79), (-14,86), (-10,73),
    (-10,70), (-10,69), (-5,66), (-9,64), (-5,58), (2,59), (21,-10), (24,-11),
    (28,-8), (28,-1), (29,3), (29,9), (35,20), (29,36), (14,67),
];

/// P-slice(cabac_init_idc=0) 上下文初始化扩展表 (ctxIdx 277..459).
///
/// 取自 FFmpeg `cabac_context_init_PB[0]`.
#[rustfmt::skip]
const CABAC_INIT_PB0_EXT_277_459: [(i8, i8); 183] = [
    (-13,106), (-16,106), (-10,87), (-21,114), (-18,110), (-14,98), (-22,110), (-21,106),
    (-18,103), (-21,107), (-23,108), (-26,112), (-10,96), (-12,95), (-5,91), (-9,93),
    (-22,94), (-5,86), (9,67), (-4,80), (-10,85), (-1,70), (7,60), (9,58),
    (5,61), (12,50), (15,50), (18,49), (17,54), (10,41), (7,46), (-1,51),
    (7,49), (8,52), (9,41), (6,47), (2,55), (13,41), (10,44), (6,50),
    (5,53), (13,49), (4,63), (6,64), (-2,69), (-2,59), (6,70), (10,44),
    (9,31), (12,43), (3,53), (14,34), (10,38), (-3,52), (13,40), (17,32),
    (7,44), (7,38), (13,50), (10,57), (26,43), (14,11), (11,14), (9,11),
    (18,11), (21,9), (23,-2), (32,-15), (32,-15), (34,-21), (39,-23), (42,-33),
    (41,-31), (46,-28), (38,-12), (21,29), (45,-24), (53,-45), (48,-26), (65,-43),
    (43,-19), (39,-10), (30,9), (18,26), (20,27), (0,57), (-14,82), (-5,75),
    (-19,97), (-35,125), (27,0), (28,0), (31,-4), (27,6), (34,8), (30,10),
    (24,22), (33,19), (22,32), (26,31), (21,41), (26,44), (23,47), (16,65),
    (14,71), (8,60), (6,63), (17,65), (21,24), (23,20), (26,23), (27,32),
    (28,23), (28,24), (23,40), (24,32), (28,29), (23,42), (19,57), (22,53),
    (22,61), (11,86), (12,40), (11,51), (14,59), (-4,79), (-7,71), (-5,69),
    (-9,70), (-8,66), (-10,68), (-19,73), (-12,69), (-16,70), (-15,67), (-20,62),
    (-19,70), (-16,66), (-22,65), (-20,63), (9,-2), (26,-9), (33,-9), (39,-7),
    (41,-2), (45,3), (49,9), (45,27), (36,59), (-6,66), (-7,35), (-7,42),
    (-8,45), (-5,48), (-12,56), (-6,60), (-5,62), (-8,66), (-8,76), (-5,85),
    (-6,81), (-10,77), (-7,81), (-17,80), (-18,73), (-4,74), (-10,83), (-9,71),
    (-9,67), (-1,61), (-8,66), (-14,66), (0,59), (2,59), (21,-13), (33,-14),
    (39,-7), (46,-2), (51,2), (60,6), (61,17), (55,34), (42,62),
];

/// I-slice 扩展上下文 (ctxIdx 1012..1023).
///
/// 取自 FFmpeg `cabac_context_init_I` 尾部 8x8 CBF 上下文.
#[rustfmt::skip]
const CABAC_INIT_I_EXT_1012_1023: [(i8, i8); 12] = [
    (-3, 70), (-8, 93), (-10, 90), (-30, 127),
    (-3, 70), (-8, 93), (-10, 90), (-30, 127),
    (-3, 70), (-8, 93), (-10, 90), (-30, 127),
];

/// P-slice(cabac_init_idc=0) 扩展上下文 (ctxIdx 1012..1023).
///
/// 取自 FFmpeg `cabac_context_init_PB[0]` 尾部 8x8 CBF 上下文.
#[rustfmt::skip]
const CABAC_INIT_PB0_EXT_1012_1023: [(i8, i8); 12] = [
    (-3, 74), (-9, 92), (-8, 87), (-23, 126),
    (-3, 74), (-9, 92), (-8, 87), (-23, 126),
    (-3, 74), (-9, 92), (-8, 87), (-23, 126),
];

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_init_contexts_pb_slice_selects_cabac_init_idc() {
        let qp = 26;
        let idx = 11usize;

        let ctx0 = init_contexts_pb_slice(qp, 0);
        let ctx1 = init_contexts_pb_slice(qp, 1);
        let ctx2 = init_contexts_pb_slice(qp, 2);
        let ctx_over = init_contexts_pb_slice(qp, 9);

        let expected0 = init_single_ctx(23, 33, qp);
        let expected1 = init_single_ctx(22, 25, qp);
        let expected2 = init_single_ctx(29, 16, qp);

        assert_eq!(
            ctx0[idx].state, expected0.state,
            "cabac_init_idc=0 的 state 错误"
        );
        assert_eq!(ctx0[idx].mps, expected0.mps, "cabac_init_idc=0 的 mps 错误");
        assert_eq!(
            ctx1[idx].state, expected1.state,
            "cabac_init_idc=1 的 state 错误"
        );
        assert_eq!(ctx1[idx].mps, expected1.mps, "cabac_init_idc=1 的 mps 错误");
        assert_eq!(
            ctx2[idx].state, expected2.state,
            "cabac_init_idc=2 的 state 错误"
        );
        assert_eq!(ctx2[idx].mps, expected2.mps, "cabac_init_idc=2 的 mps 错误");
        assert_eq!(
            ctx_over[idx].state, expected2.state,
            "cabac_init_idc 越界时应按 2 处理(state)"
        );
        assert_eq!(
            ctx_over[idx].mps, expected2.mps,
            "cabac_init_idc 越界时应按 2 处理(mps)"
        );
    }
}
